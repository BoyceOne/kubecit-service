// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v3.19.1
// source: helloworld/v1/greeter.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationGreeterSayHello = "/helloworld.v1.Greeter/SayHello"

type GreeterHTTPServer interface {
	// SayHello Sends a greeting
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}

func RegisterGreeterHTTPServer(s *http.Server, srv GreeterHTTPServer) {
	r := s.Route("/")
	r.GET("/helloworld/{name}", _Greeter_SayHello0_HTTP_Handler(srv))
}

func _Greeter_SayHello0_HTTP_Handler(srv GreeterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in HelloRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGreeterSayHello)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SayHello(ctx, req.(*HelloRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*HelloReply)
		return ctx.Result(200, reply)
	}
}

type GreeterHTTPClient interface {
	SayHello(ctx context.Context, req *HelloRequest, opts ...http.CallOption) (rsp *HelloReply, err error)
}

type GreeterHTTPClientImpl struct {
	cc *http.Client
}

func NewGreeterHTTPClient(client *http.Client) GreeterHTTPClient {
	return &GreeterHTTPClientImpl{client}
}

func (c *GreeterHTTPClientImpl) SayHello(ctx context.Context, in *HelloRequest, opts ...http.CallOption) (*HelloReply, error) {
	var out HelloReply
	pattern := "/helloworld/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationGreeterSayHello))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationCategoryCategory = "/helloworld.v1.Category/Category"

type CategoryHTTPServer interface {
	Category(context.Context, *Empty) (*CategoryResp, error)
}

func RegisterCategoryHTTPServer(s *http.Server, srv CategoryHTTPServer) {
	r := s.Route("/")
	r.GET("/api/categories", _Category_Category0_HTTP_Handler(srv))
}

func _Category_Category0_HTTP_Handler(srv CategoryHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in Empty
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCategoryCategory)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Category(ctx, req.(*Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CategoryResp)
		return ctx.Result(200, reply)
	}
}

type CategoryHTTPClient interface {
	Category(ctx context.Context, req *Empty, opts ...http.CallOption) (rsp *CategoryResp, err error)
}

type CategoryHTTPClientImpl struct {
	cc *http.Client
}

func NewCategoryHTTPClient(client *http.Client) CategoryHTTPClient {
	return &CategoryHTTPClientImpl{client}
}

func (c *CategoryHTTPClientImpl) Category(ctx context.Context, in *Empty, opts ...http.CallOption) (*CategoryResp, error) {
	var out CategoryResp
	pattern := "/api/categories"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCategoryCategory))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationCourseGetFirstCategories = "/helloworld.v1.Course/GetFirstCategories"
const OperationCourseMostNew = "/helloworld.v1.Course/MostNew"
const OperationCourseSearchCourse = "/helloworld.v1.Course/SearchCourse"
const OperationCourseTagsList = "/helloworld.v1.Course/TagsList"

type CourseHTTPServer interface {
	GetFirstCategories(context.Context, *GetFirstCategoriesRequest) (*GetFirstCategoriesReply, error)
	MostNew(context.Context, *PageRequest) (*MostNewReply, error)
	SearchCourse(context.Context, *SearchCourseRequest) (*SearchCourseReply, error)
	TagsList(context.Context, *TagsListRequest) (*TagsListReply, error)
}

func RegisterCourseHTTPServer(s *http.Server, srv CourseHTTPServer) {
	r := s.Route("/")
	r.POST("/api/course/mostNew", _Course_MostNew0_HTTP_Handler(srv))
	r.GET("/api/course/category/getFirstCategories", _Course_GetFirstCategories0_HTTP_Handler(srv))
	r.POST("/api/course/tags/list", _Course_TagsList0_HTTP_Handler(srv))
	r.POST("/api/course/search", _Course_SearchCourse0_HTTP_Handler(srv))
}

func _Course_MostNew0_HTTP_Handler(srv CourseHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCourseMostNew)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MostNew(ctx, req.(*PageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MostNewReply)
		return ctx.Result(200, reply)
	}
}

func _Course_GetFirstCategories0_HTTP_Handler(srv CourseHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFirstCategoriesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCourseGetFirstCategories)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFirstCategories(ctx, req.(*GetFirstCategoriesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFirstCategoriesReply)
		return ctx.Result(200, reply)
	}
}

func _Course_TagsList0_HTTP_Handler(srv CourseHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TagsListRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCourseTagsList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TagsList(ctx, req.(*TagsListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TagsListReply)
		return ctx.Result(200, reply)
	}
}

func _Course_SearchCourse0_HTTP_Handler(srv CourseHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SearchCourseRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCourseSearchCourse)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SearchCourse(ctx, req.(*SearchCourseRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SearchCourseReply)
		return ctx.Result(200, reply)
	}
}

type CourseHTTPClient interface {
	GetFirstCategories(ctx context.Context, req *GetFirstCategoriesRequest, opts ...http.CallOption) (rsp *GetFirstCategoriesReply, err error)
	MostNew(ctx context.Context, req *PageRequest, opts ...http.CallOption) (rsp *MostNewReply, err error)
	SearchCourse(ctx context.Context, req *SearchCourseRequest, opts ...http.CallOption) (rsp *SearchCourseReply, err error)
	TagsList(ctx context.Context, req *TagsListRequest, opts ...http.CallOption) (rsp *TagsListReply, err error)
}

type CourseHTTPClientImpl struct {
	cc *http.Client
}

func NewCourseHTTPClient(client *http.Client) CourseHTTPClient {
	return &CourseHTTPClientImpl{client}
}

func (c *CourseHTTPClientImpl) GetFirstCategories(ctx context.Context, in *GetFirstCategoriesRequest, opts ...http.CallOption) (*GetFirstCategoriesReply, error) {
	var out GetFirstCategoriesReply
	pattern := "/api/course/category/getFirstCategories"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCourseGetFirstCategories))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *CourseHTTPClientImpl) MostNew(ctx context.Context, in *PageRequest, opts ...http.CallOption) (*MostNewReply, error) {
	var out MostNewReply
	pattern := "/api/course/mostNew"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCourseMostNew))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *CourseHTTPClientImpl) SearchCourse(ctx context.Context, in *SearchCourseRequest, opts ...http.CallOption) (*SearchCourseReply, error) {
	var out SearchCourseReply
	pattern := "/api/course/search"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCourseSearchCourse))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *CourseHTTPClientImpl) TagsList(ctx context.Context, in *TagsListRequest, opts ...http.CallOption) (*TagsListReply, error) {
	var out TagsListReply
	pattern := "/api/course/tags/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCourseTagsList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationSliderGetSliders = "/helloworld.v1.Slider/GetSliders"

type SliderHTTPServer interface {
	GetSliders(context.Context, *GetSlidersRequest) (*GetSlidersReply, error)
}

func RegisterSliderHTTPServer(s *http.Server, srv SliderHTTPServer) {
	r := s.Route("/")
	r.GET("/api/slider/getSliders", _Slider_GetSliders0_HTTP_Handler(srv))
}

func _Slider_GetSliders0_HTTP_Handler(srv SliderHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetSlidersRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSliderGetSliders)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSliders(ctx, req.(*GetSlidersRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetSlidersReply)
		return ctx.Result(200, reply)
	}
}

type SliderHTTPClient interface {
	GetSliders(ctx context.Context, req *GetSlidersRequest, opts ...http.CallOption) (rsp *GetSlidersReply, err error)
}

type SliderHTTPClientImpl struct {
	cc *http.Client
}

func NewSliderHTTPClient(client *http.Client) SliderHTTPClient {
	return &SliderHTTPClientImpl{client}
}

func (c *SliderHTTPClientImpl) GetSliders(ctx context.Context, in *GetSlidersRequest, opts ...http.CallOption) (*GetSlidersReply, error) {
	var out GetSlidersReply
	pattern := "/api/slider/getSliders"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSliderGetSliders))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationTokenCreateToken = "/helloworld.v1.Token/CreateToken"

type TokenHTTPServer interface {
	CreateToken(context.Context, *CreateTokenRequest) (*CreateTokenReply, error)
}

func RegisterTokenHTTPServer(s *http.Server, srv TokenHTTPServer) {
	r := s.Route("/")
	r.GET("/api/token/createToken", _Token_CreateToken0_HTTP_Handler(srv))
}

func _Token_CreateToken0_HTTP_Handler(srv TokenHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTokenRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTokenCreateToken)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateToken(ctx, req.(*CreateTokenRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateTokenReply)
		return ctx.Result(200, reply)
	}
}

type TokenHTTPClient interface {
	CreateToken(ctx context.Context, req *CreateTokenRequest, opts ...http.CallOption) (rsp *CreateTokenReply, err error)
}

type TokenHTTPClientImpl struct {
	cc *http.Client
}

func NewTokenHTTPClient(client *http.Client) TokenHTTPClient {
	return &TokenHTTPClientImpl{client}
}

func (c *TokenHTTPClientImpl) CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...http.CallOption) (*CreateTokenReply, error) {
	var out CreateTokenReply
	pattern := "/api/token/createToken"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationTokenCreateToken))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationMemberGetInfo = "/helloworld.v1.Member/GetInfo"

type MemberHTTPServer interface {
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoReply, error)
}

func RegisterMemberHTTPServer(s *http.Server, srv MemberHTTPServer) {
	r := s.Route("/")
	r.GET("/api/member/getInfo", _Member_GetInfo0_HTTP_Handler(srv))
}

func _Member_GetInfo0_HTTP_Handler(srv MemberHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetInfoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMemberGetInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetInfo(ctx, req.(*GetInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetInfoReply)
		return ctx.Result(200, reply)
	}
}

type MemberHTTPClient interface {
	GetInfo(ctx context.Context, req *GetInfoRequest, opts ...http.CallOption) (rsp *GetInfoReply, err error)
}

type MemberHTTPClientImpl struct {
	cc *http.Client
}

func NewMemberHTTPClient(client *http.Client) MemberHTTPClient {
	return &MemberHTTPClientImpl{client}
}

func (c *MemberHTTPClientImpl) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...http.CallOption) (*GetInfoReply, error) {
	var out GetInfoReply
	pattern := "/api/member/getInfo"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMemberGetInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationLoginLoginByJson = "/helloworld.v1.Login/LoginByJson"

type LoginHTTPServer interface {
	LoginByJson(context.Context, *LoginByJsonRequest) (*LoginByJsonReply, error)
}

func RegisterLoginHTTPServer(s *http.Server, srv LoginHTTPServer) {
	r := s.Route("/")
	r.POST("/api/u/loginByJson", _Login_LoginByJson0_HTTP_Handler(srv))
}

func _Login_LoginByJson0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginByJsonRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLoginLoginByJson)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LoginByJson(ctx, req.(*LoginByJsonRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginByJsonReply)
		return ctx.Result(200, reply)
	}
}

type LoginHTTPClient interface {
	LoginByJson(ctx context.Context, req *LoginByJsonRequest, opts ...http.CallOption) (rsp *LoginByJsonReply, err error)
}

type LoginHTTPClientImpl struct {
	cc *http.Client
}

func NewLoginHTTPClient(client *http.Client) LoginHTTPClient {
	return &LoginHTTPClientImpl{client}
}

func (c *LoginHTTPClientImpl) LoginByJson(ctx context.Context, in *LoginByJsonRequest, opts ...http.CallOption) (*LoginByJsonReply, error) {
	var out LoginByJsonReply
	pattern := "/api/u/loginByJson"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLoginLoginByJson))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
